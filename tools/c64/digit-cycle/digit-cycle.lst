
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -o digit-cycle.prg -L digit-cycle.lst --verbose-list digit-cycle.asm
; Sun Sep 28 12:37:22 2025

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: digit-cycle.asm

					; C64 Digit Cycling Display - Full Screen
					; Cycles through digits 0-9 on entire 40x25 screen (1000 characters)

					; BASIC Loader: 10 SYS <start_address>
					*=$0801                         ; BASIC program start
.0801					basic_stub:
>0801	0c 08				        .word basic_end         ; Next line pointer
>0803	0a 00				        .word 10                ; Line number 10
>0805	9e				        .byte $9e               ; SYS token
>0806	20				        .byte " "
>0807	32 30 36 32			        .text format("%4d", start)  ; Auto-calculated SYS address
>080b	00				        .byte 0                 ; End of BASIC line
.080c					basic_end:
>080c	00 00				        .word 0                 ; End of BASIC program

.080e					start:
					        ; Initialize variables
.080e	a9 30		lda #$30	        lda #$30                ; ASCII '0'
.0810	8d 69 08	sta $0869	        sta current_digit

					        ; Set colors once at startup (light blue on dark blue)
.0813	a0 00		ldy #$00	        ldy #0
.0815	a2 00		ldx #$00	        ldx #0
.0817	a9 0e		lda #$0e	        lda #$0e                ; Light blue

.0819					fill_colors_startup:
.0819	99 00 d8	sta $d800,y	        sta $d800,y            ; Color memory starts at $d800
.081c	99 00 d9	sta $d900,y	        sta $d900,y
.081f	99 00 da	sta $da00,y	        sta $da00,y
.0822	99 00 db	sta $db00,y	        sta $db00,y

.0825	c8		iny		        iny
.0826	d0 f1		bne $0819	        bne fill_colors_startup

.0828	e8		inx		        inx
.0829	e0 04		cpx #$04	        cpx #4
.082b	d0 ec		bne $0819	        bne fill_colors_startup

.082d	c0 e8		cpy #$e8	        cpy #$e8               ; Check for exactly 1000 chars
.082f	d0 e8		bne $0819	        bne fill_colors_startup

.0831					main_loop:
					        ; Wait for raster line 255
.0831					wait_raster:
.0831	ad 12 d0	lda $d012	        lda $d012              ; Current raster line
.0834	c9 ff		cmp #$ff	        cmp #255               ; Wait for line 255
.0836	d0 f9		bne $0831	        bne wait_raster

					        ; Fill entire screen with current digit
.0838	a0 00		ldy #$00	        ldy #0                 ; Screen position counter (low byte)
.083a	a2 00		ldx #$00	        ldx #0                 ; Screen position counter (high byte)
.083c	ad 69 08	lda $0869	        lda current_digit      ; Current digit character

.083f					fill_screen:
.083f	99 00 04	sta $0400,y	        sta $0400,y            ; Screen memory starts at $0400
.0842	99 00 05	sta $0500,y	        sta $0500,y            ; Continue through screen memory
.0845	99 00 06	sta $0600,y	        sta $0600,y
.0848	99 00 07	sta $0700,y	        sta $0700,y

					        ; Check if we've filled all 1000 characters (40*25)
.084b	c8		iny		        iny
.084c	d0 f1		bne $083f	        bne fill_screen        ; If Y didn't wrap, continue

.084e	e8		inx		        inx                    ; Increment high byte
.084f	e0 04		cpx #$04	        cpx #4                 ; Have we done 4*256 = 1024 chars?
.0851	d0 ec		bne $083f	        bne fill_screen

					        ; Check if we've actually done exactly 1000 chars
.0853	c0 e8		cpy #$e8	        cpy #$e8               ; 1000 = 3*256 + 232 = $3e8, so check Y=$e8
.0855	d0 e8		bne $083f	        bne fill_screen

					        ; Advance to next digit
.0857	ee 69 08	inc $0869	        inc current_digit
.085a	ad 69 08	lda $0869	        lda current_digit
.085d	c9 3a		cmp #$3a	        cmp #$3a               ; ASCII '9' + 1
.085f	d0 d0		bne $0831	        bne main_loop

					        ; Reset to '0'
.0861	a9 30		lda #$30	        lda #$30
.0863	8d 69 08	sta $0869	        sta current_digit
.0866	4c 31 08	jmp $0831	        jmp main_loop

					; Variables
>0869	30				current_digit:  .byte $30      ; Current digit (ASCII '0'-'9')

;******  End of listing
